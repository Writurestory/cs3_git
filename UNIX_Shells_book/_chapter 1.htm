<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Chapter 1</title>
<link rel="stylesheet" type="text/css" href="docsafari.css">
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body><table width="100%" border="1" bgcolor="#EBEBFF"><tr><td width="5%" align="left" valign="middle"><a href="_chapter 0.htm"><img src="Larrow.gif" width="17" height="19" border="0"></a></td><td align="center" valign="middle"><a class="docLink" href="Front matter.htm">CONTENTS</a></td><td width="5%" align="right" valign="middle"><a href="_chapter 2.htm"><img src="Rarrow.gif" width="17" height="19" border="0"></a></td></tr></table>


<h2 class="docChapterTitle">Chapter 1. Introduction to UNIX Shells</h2><ul><li>&nbsp;<a class="docLink" href="#ch01lev1sec1">1.1 Definition and Function</a></li>
<li>&nbsp;<a class="docLink" href="#ch01lev1sec2">1.2 System Startup and the Login Shell</a></li>
<li>&nbsp;<a class="docLink" href="#ch01lev1sec3">1.3 Processes and the Shell</a></li>
<li>&nbsp;<a class="docLink" href="#ch01lev1sec4">1.4 The Environment and Inheritance</a></li>
<li>&nbsp;<a class="docLink" href="#ch01lev1sec5">1.5 Executing Commands from Scripts</a></li>
</ul>
<p class="docText">
<img alt="graphics/ch01.gif" src="ch01.gif" border="0" width="500" height="353"></p>
<h3 class="docSection1Title" id="ch01lev1sec1">1.1 Definition and Function</h3>
<p class="docText">The shell is a special program used as an interface between 
the user and the heart of the UNIX operating system, a program called the
<span class="docEmphasis">kernel,</span> as shown in
<a class="docLink" href="#ch01fig01">Figure 1.1</a>. The kernel is loaded into 
memory at boot-up time and manages the system until shutdown. It creates and 
controls processes, and manages memory, file systems, communications, and so 
forth. All other programs, including shell programs, reside out on the disk. The 
kernel loads those programs into memory, executes them, and cleans up the system 
when they terminate. The shell is a utility program that starts up when you log 
on. It allows users to interact with the kernel by interpreting commands that 
are typed either at the command line or in a script file.</p>
<center>
<h5 id="ch01fig01" class="docFigureTitle">Figure 1.1. The kernel, the shell, and you.</h5>
<p class="docText">
<img alt="graphics/01fig01.gif" src="01fig01.gif" border="0" width="500" height="299"></p>
</center>
<p class="docText">When you log on, an interactive shell starts up and prompts 
you for input. After you type a command, it is the responsibility of the shell 
to (a) parse the command line; (b) handle wildcards, redirection, pipes, and job 
control; and (c) search for the command, and if found, execute that command. 
When you first learn UNIX, you spend most of your time executing commands from 
the prompt. You use the shell interactively.</p>
<p class="docText">If you type the same set of commands on a regular basis, you 
may want to automate those tasks. This can be done by putting the commands in a 
file, called a <span class="docEmphasis">script file,</span> and then executing 
the file. A shell script is much like a batch file: It is a list of UNIX 
commands typed into a file, and then the file is executed. More sophisticated 
scripts contain programming constructs for making decisions, looping, file 
testing, and so forth. Writing scripts not only requires learning programming 
constructs and techniques, but assumes that you have a good understanding of 
UNIX utilities and how they work. There are some utilities, such as
<span class="docEmphasis">grep, sed,</span> and <span class="docEmphasis">awk,</span> 
that are extremely powerful tools used in scripts for the manipulation of 
command output and files. After you have become familiar with these tools and 
the programming constructs for your particular shell, you will be ready to start 
writing useful scripts. When executing commands from within a script, you are 
using the shell as a programming language.</p>
<h4 class="docSection2Title" id="ch01lev2sec1">1.1.1 The Three Major UNIX Shells</h4>
<p class="docText">The three prominent and supported shells on most UNIX systems 
are the <span class="docEmphasis">Bourne</span> shell (AT&amp;T shell), the
<span class="docEmphasis">C</span> shell (Berkeley shell), and the
<span class="docEmphasis">Korn</span> shell (superset of the Bourne shell). All 
three of these behave pretty much the same way when running interactively, but 
have some differences in syntax and efficiency when used as scripting languages.</p>
<p class="docText">The Bourne shell is the standard UNIX shell, and is used to 
administer the system. Most of the system administration scripts, such as the
<span class="docEmphasis">rc</span> <span class="docEmphasis">start</span> and
<span class="docEmphasis">stop</span> scripts and <span class="docEmphasis">
shutdown</span> are Bourne shell scripts, and when in single user mode, this is 
the shell commonly used by the administrator when running as root. This shell 
was written at AT&amp;T and is known for being concise, compact, and fast. The 
default Bourne shell prompt is the dollar sign (<span class="docEmphasis">$</span>).</p>
<p class="docText">The C shell was developed at Berkeley and added a number of 
features, such as command line history, aliasing, built-in arithmetic, filename 
completion, and job control. The C shell has been favored over the Bourne shell 
by users running the shell interactively, but administrators prefer the Bourne 
shell for scripting, because Bourne shell scripts are simpler and faster than 
the same scripts written in C shell. The default C shell prompt is the percent 
sign (<span class="docEmphasis">%</span>).</p>
<p class="docText">The Korn shell is a superset of the Bourne shell written by 
David Korn at AT&amp;T. A number of features were added to this shell above and 
beyond the enhancements of the C shell. Korn shell features include an editable 
history, aliases, functions, regular expression wildcards, built-in arithmetic, 
job control, coprocessing, and special debugging features. The Bourne shell is 
almost completely upward-compatible with the Korn shell, so older Bourne shell 
programs will run fine in this shell. The default Korn shell prompt is the 
dollar sign (<span class="docEmphasis">$</span>).</p>
<h4 class="docSection2Title" id="ch01lev2sec2">1.1.2 The Linux Shells</h4>
<p class="docText">Although often called &quot;Linux&quot; shells, Bash and TC shells are 
freely available and can be compiled on any UNIX system; in fact, the shells are 
now bundled with Solaris 8 and Sun's UNIX operating system. But when you install 
Linux, you will have access to the GNU shells and tools, and not the standard 
UNIX shells and tools. Although Linux supports a number of shells, the Bourne 
Again shell (<span class="docEmphasis">bash)</span> and the TC shell (<span class="docEmphasis">tcsh)</span> 
are by far the most popular. The Z shell is another Linux shell that 
incorporates a number of features from the Bourne Again shell, the TC shell, and 
the Korn shell. The Public Domain Korn shell (<span class="docEmphasis">pdksh</span>) 
a Korn shell clone, is also available, and for a fee you can get AT&amp;T's Korn 
shell, not to mention a host of other unknown smaller shells.</p>
<p class="docText">To see what shells are available under your version of Linux, 
look in the file, <span class="docEmphasis">/etc/shell.</span></p>
<p class="docText">To change to one of the shells listed in
<span class="docEmphasis">/etc/shell,</span> type the <span class="docEmphasis">
chsh</span> command and the name of the shell. For example, to change 
permanently to the TC shell, use the <span class="docEmphasis">chsh</span> 
command. At the prompt, type:</p>
<pre>chsh /bin/tcsh</pre>
<h4 class="docSection2Title" id="ch01lev2sec3">1.1.3 History of the Shell</h4>
<p class="docText">The first significant, standard UNIX shell was introduced in 
V7 (seventh edition of AT&amp;T) UNIX in late 1979, and was named after its creator, 
Stephen Bourne. The Bourne shell as a programming language is based on a 
language called Algol, and was primarily used to automate system administration 
tasks. Although popular for its simplicity and speed, it lacks many of the 
features for interactive use, such as history, aliasing, and job control. Enter
<span class="docEmphasis">bash,</span> the Bourne Again shell, which was 
developed by Brian Fox of the Free Software Foundation under the GNU copyright 
license and is the default shell for the very popular Linux operating system. It 
was intended to conform to the IEEE POSIX P1003.2/ISO 9945.2 Shell and Tools 
standard. <span class="docEmphasis">Bash</span> also offers a number of new 
features (both at the interactive and programming level) missing in the original 
Bourne shell (yet Bourne shell scripts will still run unmodified). It also 
incorporates the most useful features of both the C shell and Korn shell. It's 
big. The improvements over Bourne shell are: command line history and editing, 
directory stacks, job control, functions, aliases, arrays, integer arithmetic 
(in any base from 2 to 64), and Korn shell features, such as extended 
metacharacters, select loops for creating menus, the <span class="docEmphasis">
let</span> command, etc.</p>
<p class="docText">The C shell, developed at the University of California at 
Berkeley in the late 1970s, was released as part of 2BSD UNIX. The shell, 
written primarily by Bill Joy, offered a number of additional features not 
provided in the standard Bourne shell. The C shell is based on the C programming 
language, and when used as a programming language, it shares a similar syntax. 
It also offers enhancements for interactive use, such as command line history, 
aliases, and job control. Because the shell was designed on a large machine and 
a number of additional features were added, the C shell has a tendency to be 
slow on small machines and sluggish even on large machines when compared to the 
Bourne shell.</p>
<p class="docText">The TC shell is an expanded version of the C shell. Some of 
the new features are: command line editing (<span class="docEmphasis">emacs</span> 
and <span class="docEmphasis">vi</span>), scrolling the history list, advanced 
filename, variable, and command completion, spelling correction, scheduling 
jobs, automatic locking and logout, time stamps in the history list, etc. It's 
also big.</p>
<p class="docText">With both the Bourne shell and the C shell available, the 
UNIX user now had a choice, and conflicts arose over which was the better shell. 
David Korn, from AT&amp;T, invented the Korn shell in the mid-1980s. It was released 
in 1986 and officially became part of the SVR4 distribution of UNIX in 1988. The 
Korn shell, really a superset of the Bourne shell, runs not only on UNIX 
systems, but also on OS/2, VMS, and DOS. It provides upward-compatibility with 
the Bourne shell, adds many of the popular features of the C shell, and is fast 
and efficient. The Korn shell has gone through a number of revisions. The most 
widely used version of the Korn shell is the 1988 version, although the 1993 
version is gaining popularity. Linux users may find they are running the free 
version of the Korn shell, called The Public Domain Korn shell, or simply
<span class="docEmphasis">pdksh,</span> a clone of David Korn's 1988 shell. It 
is free and portable and currently work is underway to make it fully compatible 
with its namesake, Korn shell, and to make it POSIX compliant. Also available is 
the Z shell (<span class="docEmphasis">zsh</span>), another Korn shell clone 
with TC shell features, written by Paul Falsted, and freely available at a 
number of Web sites.</p>
<h4 class="docSection2Title" id="ch01lev2sec4">1.1.4 Uses of the Shell</h4>
<p class="docText">One of the major functions of a shell is to interpret 
commands entered at the command line prompt when running interactively. The 
shell parses the command line, breaking it into words (called
<span class="docEmphasis">tokens</span>), separated by whitespace, which 
consists of tabs, spaces, or a newline. If the words contain special 
metacharacters, the shell evaluates them. The shell handles file I/O and 
background processing. After the command line has been processed, the shell 
searches for the command and starts its execution.</p>
<p class="docText">Another important function of the shell is to customize the 
user's environment, normally done in shell initialization files. These files 
contain definitions for setting terminal keys and window characteristics; 
setting variables that define the search path, permissions, prompts, and the 
terminal type; and setting variables that are required for specific applications 
such as windows, text-processing programs, and libraries for programming 
languages. The Korn shell and C shell also provide further customization with 
the addition of history and aliases, built-in variables set to protect the user 
from clobbering files or inadvertently logging out, and to notify the user when 
a job has completed.</p>
<p class="docText">The shell can also be used as an interpreted programming 
language. Shell programs, also called scripts, consist of commands listed in a 
file. The programs are created in an editor (although on-line scripting is 
permitted). They consist of UNIX commands interspersed with fundamental 
programming constructs such as variable assignment, conditional tests, and 
loops. You do not have to compile shell scripts. The shell interprets each line 
of the script as if it had been entered from the keyboard. Because the shell is 
responsible for interpreting commands, it is necessary for the user to have an 
understanding of what those commands are. See
<a class="docLink" href="Appendix A.htm">Appendix A</a> for a 
list of useful commands.</p>
<h4 class="docSection2Title" id="ch01lev2sec5">1.1.5 Responsibilities of the Shell</h4>
<p class="docText">The shell is ultimately responsible for making sure that any 
commands typed at the prompt get properly executed. Included in those 
responsibilities are:</p>
<span style="FONT-WEIGHT: bold">
<ol class="docList" type="1">
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Reading input and parsing the command line.</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Evaluating special characters.</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Setting up pipes, redirection, and background processing.</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Handling signals.</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Setting up programs for execution.</span></li>
</ol>
</span>
<p class="docText">Each of these topics is discussed in detail as it pertains to 
a particular shell.</p>
<h3 class="docSection1Title" id="ch01lev1sec2">1.2 System Startup and the Login Shell</h3>
<p class="docText">When you start up your system, the first process is called
<span class="docEmphasis">init.</span> Each process has a process identification 
number associated with it, called the <span class="docEmphasis">PID</span>. 
Since <span class="docEmphasis">init</span> is the first process, its PID is 1. 
The <span class="docEmphasis">init</span> process initializes the system and 
then starts another process to open terminal lines and set up the standard input 
(<span class="docEmphasis">stdin</span>), standard output (<span class="docEmphasis">stdout</span>), 
and standard error (<span class="docEmphasis">stderr</span>), which are all 
associated with the terminal. The standard input normally comes from the 
keyboard; the standard output and standard error go to the screen. At this 
point, a login prompt would appear on your terminal.</p>
<p class="docText">After you type your login name, you will be prompted for a 
password. The <span class="docEmphasis">/bin/login</span> program then verifies 
your identity by checking the first field in the <span class="docEmphasis">
passwd</span> file. If your username is there, the next step is to run the 
password you typed through an encryption program to determine if it is indeed 
the correct password. Once your password is verified, the
<span class="docEmphasis">login</span> program sets up an initial environment 
consisting of variables that define the working environment that will be passed 
on to the shell. The <span class="docEmphasis">HOME,</span>
<span class="docEmphasis">SHELL,</span> <span class="docEmphasis">USER,</span> 
and <span class="docEmphasis">LOGNAME</span> variables are assigned values 
extracted from information in the <span class="docEmphasis">passwd</span> file. 
The <span class="docEmphasis">HOME</span> variable is assigned your home 
directory; the <span class="docEmphasis">SHELL</span> variable is assigned the 
name of the login shell, which is the last entry in the
<span class="docEmphasis">passwd</span> file. The <span class="docEmphasis">USER</span> 
and/or <span class="docEmphasis">LOGNAME</span> variables are assigned your 
login name. A <span class="docEmphasis">search path</span> variable is set so 
that commonly used utilities may be found in specified directories. When
<span class="docEmphasis">login</span> has finished, it will execute the program 
found in the last entry of the <span class="docEmphasis">passwd</span> file. 
Normally, this program is a shell. If the last entry in the
<span class="docEmphasis">passwd</span> file is <span class="docEmphasis">/bin/csh,</span> 
the C shell program is executed. If the last entry in the
<span class="docEmphasis">passwd</span> file is <span class="docEmphasis">/bin/sh</span> 
or is null, the Bourne shell starts up. If the last entry is
<span class="docEmphasis">/bin/ksh,</span> the Korn shell is executed. This 
shell is called the <span class="docEmphasis">login shell.</span></p>
<p class="docText">After the shell starts up, it checks for any systemwide 
initialization files set up by the system administrator and then checks your 
home directory to see if there are any shell-specific initialization files 
there. If any of these files exist, they are executed. The initialization files 
are used to further customize the user environment. After the commands in those 
files have been executed, a prompt appears on the screen. The shell is now 
waiting for your input.</p>
<h4 class="docSection2Title" id="ch01lev2sec6">1.2.1 Parsing the Command Line</h4>
<p class="docText">When you type a command at the prompt, the shell reads a line 
of input and parses the command line, breaking the line into words, called 
tokens. Tokens are separated by spaces and tabs and the command line is 
terminated by a newline.<span id="ENB1-1"><a class="docLink" href="#EN1-1"><sup>[1]</sup></a></span> 
The shell then checks to see whether the first word is a built-in command or an 
executable program located somewhere out on disk. If it is built-in, the shell 
will execute the command internally. Otherwise, the shell will search the 
directories listed in the path variable to find out where the program resides. 
If the command is found, the shell will fork a new process and then execute the 
program. The shell will sleep (or wait) until the program finishes execution and 
then, if necessary, will report the status of the exiting program. A prompt will 
appear and the whole process will start again. The order of processing the 
command line is as follows:</p>
<span style="FONT-WEIGHT: bold">
<ol class="docList" type="1">
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">History substitution is performed (if applicable).</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Command line is broken up into tokens, or words.</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">History is updated (if applicable).</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Quotes are processed.</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Alias substitution and functions are defined (if 
  applicable).</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Redirection, background, and pipes are set up.</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Variable substitution (<span class="docEmphasis">$user,</span>
  <span class="docEmphasis">$name,</span> etc.) is performed.</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Command substitution (echo for <span class="docEmphasis">
  today is 'date'</span>) is performed.</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Filename substitution, called <span class="docEmphasis">
  globbing</span> (<span class="docEmphasis">cat abc.??,</span>
  <span class="docEmphasis">rm *.c,</span> etc.) is performed.</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Program execution.</span></li>
</ol>
</span>
<h4 class="docSection2Title" id="ch01lev2sec7">1.2.2 Types of Commands</h4>
<p class="docText">When a command is executed, it is an alias, a function, a 
built-in command, or an executable program on disk. Aliases are abbreviations 
(nicknames) for existing commands and apply to the C, TC, Bash, and Korn shells. 
Functions apply to the Bourne (introduced with AT&amp;T System V, Release 2.0), 
Bash, and Korn shells. They are groups of commands organized as separate 
routines. Aliases and functions are defined within the shell's memory. Built-in 
commands are internal routines in the shell, and executable programs reside on 
disk. The shell uses the path variable to locate the executable programs on disk 
and forks a child process before the command can be executed. This takes time. 
When the shell is ready to execute the command, it evaluates command types in 
the following order:<span id="ENB1-2"><a class="docLink" href="#EN1-2"><sup>[2]</sup></a></span></p>
<span style="FONT-WEIGHT: bold">
<ol class="docList" type="1">
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Aliases</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Keywords</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Functions (<span class="docEmphasis">bash</span>)</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Built-in commands</span></li>
  <li><span style="FONT-WEIGHT: normal">
  <p class="docList">Executable programs</span></li>
</ol>
</span>
<p class="docText">If, for example, the command is <span class="docEmphasis">xyz</span> 
the shell will check to see if <span class="docEmphasis">xyz</span> is an alias. 
If not, is it a built-in command or a function? If neither of those, it must be 
an executable command residing on the disk. The shell then must search the path 
for the command.</p>
<h3 class="docSection1Title" id="ch01lev1sec3">1.3 Processes and the Shell</h3>
<p class="docText">A process is a program in execution and can be identified by 
its unique PID (process identification) number. The kernel controls and manages 
processes. A process consists of the executable program, its data and stack, 
program and stack pointer, registers, and all the information needed for the 
program to run. When you start the shell, it is a process. The shell belongs to 
a process group identified by the group's PID. Only one process group has 
control of the terminal at a time and is said to be running in the foreground. 
When you log on, your shell is in control of the terminal and waits for you to 
type a command at the prompt.</p>
<p class="docText">The shell can spawn other processes. In fact, when you enter 
a command at the prompt or from a shell script, the shell has the responsibility 
of finding the command either in its internal code (built-in) or out on the disk 
and then arranging for the command to be executed. This is done with calls to 
the kernel, called <span class="docEmphasis">system calls.</span> A system call 
is a request for kernel services and is the only way a process can access the 
system's hardware. There are a number of system calls that allow processes to be 
created, executed, and terminated. (The shell provides other services from the 
kernel when it performs redirection and piping, command substitution, and the 
execution of user commands.)</p>
<p class="docText">The system calls used by the shell to cause new processes to 
run are discussed in the following sections. See
<a class="docLink" href="#ch01fig02">Figure 1.2</a>.</p>
<center>
<h5 id="ch01fig02" class="docFigureTitle">Figure 1.2. The shell and command execution.</h5>
<p class="docText">
<img alt="graphics/01fig02.gif" src="01fig02.gif" border="0" width="500" height="695"></p>
</center>
<h4 class="docSection2Title" id="ch01lev2sec8">1.3.1 What Processes Are Running?</h4>
<p class="docText"><span class="docEmphStrong">The <span class="docEmphasis">ps</span> 
Command.</span> The <span class="docEmphasis">ps</span> command with its many 
options displays a list of the processes currently running in a number of 
formats. <a class="docLink" href="#ch01list01">Example 1.1</a> shows all 
processes that are running by users on a Linux system. (See
<a class="docLink" href="Appendix A.htm">Appendix A</a> for
<span class="docEmphasis">ps</span> and its options.)</p>
<h5 id="ch01list01" class="docExampleTitle">Example 1.1 </h5>
<pre>$ <span class="docEmphStrong">ps au</span>  <span class="docEmphasis">(BSD/Linux ps)  (use ps -ef for SVR4)</span>
USER   PID %CPU %MEM  SIZE   RSS TTY STAT START  TIME COMMAND
ellie  456  0.0  1.3  1268   840   1 S    13:23  0:00 -bash
ellie  476  0.0  1.0  1200   648   1 S    13:23  0:00 sh /usr/X11R6/bin/sta
ellie  478  0.0  1.0  2028   676   1 S    13:23  0:00 xinit /home/ellie/.xi
ellie  480  0.0  1.6  1852  1068   1 S    13:23  0:00 fvwm2
ellie  483  0.0  1.3  1660   856   1 S    13:23  0:00 /usr/X11R6/lib/X11/fv
ellie  484  0.0  1.3  1696   868   1 S    13:23  0:00 /usr/X11R6/lib/X11/fv
ellie  487  0.0  2.0  2348  1304   1 S    13:23  0:00 xclock -bg #c0c0c0 -p
ellie  488  0.0  1.1  1620   724   1 S    13:23  0:00 /usr/X11R6/lib/X11/fv
ellie  489  0.0  2.0  2364  1344   1 S    13:23  0:00 xload -nolabel -bg gr
ellie  495  0.0  1.3  1272   848  p0 S    13:24  0:00 -bash
ellie  797  0.0  0.7   852   484  p0 R    14:03  0:00 ps au
root   457  0.0  0.4   724   296   2 S    13:23  0:00 /sbin/mingetty tty2
root   458  0.0  0.4   724   296   3 S    13:23  0:00 /sbin/mingetty tty3
root   459  0.0  0.4   724   296   4 S    13:23  0:00 /sbin/mingetty tty4
root   460  0.0  0.4   724   296   5 S    13:23  0:00 /sbin/mingetty tty5
root   461  0.0  0.4   724   296   6 S    13:23  0:00 /sbin/mingetty tty6
root   479  0.0  4.5 12092  2896   1 S    13:23  0:01 X :0
root   494  0.0  2.5  2768  1632   1 S    13:24  0:00 nxterm -ls -sb -fn
</pre>
<h4 class="docSection2Title" id="ch01lev2sec9">1.3.2 Creating Processes</h4>
<p class="docText"><span class="docEmphStrong">The <span class="docEmphasis">
fork</span> System Call. </span>A process is created in UNIX with the
<span class="docEmphasis">fork</span> system call. The <span class="docEmphasis">
fork</span> system call creates a duplicate of the calling process. The new 
process is called the <span class="docEmphasis">child</span> and the process 
that created it is called the <span class="docEmphasis">parent.</span> The child 
process starts running right after the call to <span class="docEmphasis">fork,</span> 
and both processes initially share the CPU. The child process has a copy of the 
parent's environment, open files, real and user identifications,
<span class="docEmphasis">umask,</span> current working directory, and signals.</p>
<p class="docText">When you type a command, the shell parses the command line 
and determines whether the first word is a built-in command or an executable 
command that resides out on the disk. If the command is built-in, the shell 
handles it, but if on the disk, the shell invokes the <span class="docEmphasis">
fork</span> system call to make a copy of itself (<a class="docLink" href="#ch01fig03">Figure 
1.3</a>). Its child will search the path to find the command, as well as set up 
the file descriptors for redirection, pipes, command substitution, and 
background processing. While the child shell works, the parent normally sleeps. 
(See <span class="docEmphasis">wait,</span> below.)</p>
<center>
<h5 id="ch01fig03" class="docFigureTitle">Figure 1.3. The <span class="docEmphasis">fork</span> 
system call.</h5>
<p class="docText">
<img alt="graphics/01fig03.gif" src="01fig03.gif" border="0" width="500" height="284"></p>
</center>
<p class="docText"><span class="docEmphStrong">The <span class="docEmphasis">
wait</span> System Call. </span>The parent shell is programmed to go to sleep 
(wait) while the child takes care of details such as handling redirection, 
pipes, and background processing. The <span class="docEmphasis">wait</span> 
system call causes the parent process to suspend until one of its children 
terminates. If <span class="docEmphasis">wait</span> is successful, it returns 
the PID of the child that died and the child's exit status. If the parent does 
not wait and the child exits, the child is put in a zombie state (suspended 
animation) and will stay in that state until either the parent calls
<span class="docEmphasis">wait</span> or the parent dies.<span id="ENB1-3"><a class="docLink" href="#EN1-3"><sup>[3]</sup></a></span> 
If the parent dies before the child, the <span class="docEmphasis">init</span> 
process adopts any orphaned zombie process. The <span class="docEmphasis">wait</span> 
system call, then, is not just used to put a parent to sleep, but also to ensure 
that the process terminates properly. </p>
<p class="docText"><span class="docEmphStrong">The <span class="docEmphasis">
exec</span> System Call. </span>After you enter a command at the terminal, the 
shell normally forks off a new shell process: the child process. As mentioned 
earlier, the child shell is responsible for causing the command you typed to be 
executed. It does this by calling the <span class="docEmphasis">exec</span> 
system call. Remember, the user command is really just an executable program. 
The shell searches the path for the new program. If it is found, the shell calls 
the <span class="docEmphasis">exec</span> system call with the name of the 
command as its argument. The kernel loads this new program into memory in place 
of the shell that called it. The child shell, then, is overlaid with the new 
program. The new program becomes the child process and starts executing. 
Although the new process has its own local variables, all environment variables, 
open files, signals, and the current working directory are passed to the new 
process. This process exits when it has finished, and the parent shell wakes up.</p>
<p class="docText"><span class="docEmphStrong">The <span class="docEmphasis">
exit</span> System Call. </span>A new program can terminate at any time by 
executing the <span class="docEmphasis">exit</span> call. When a child process 
terminates, it sends a signal (<span class="docEmphasis">sigchild</span>) and 
waits for the parent to accept its exit status. The exit status is a number 
between 0 and 255. An exit status of zero indicates that the program executed 
successfully, and a nonzero exit status means that the program failed in some 
way.</p>
<p class="docText">For example, if the command <span class="docEmphasis">ls</span> 
had been typed at the command line, the parent shell would
<span class="docEmphasis">fork</span> a child process and go to sleep. The child 
shell would then <span class="docEmphasis">exec</span> (overlay) the
<span class="docEmphasis">ls</span> program in its place. The
<span class="docEmphasis">ls</span> program would run in place of the child, 
inheriting all the environment variables, open files, user information, and 
state information. When the new process finished execution, it would exit and 
the parent shell would wake up. A prompt would appear on the screen, and the 
shell would wait for another command. If you are interested in knowing how a 
command exited, each shell has a special built-in variable that contains the 
exit status of the last command that terminated. (All of this will be explained 
in detail in the individual shell chapters.) See
<a class="docLink" href="#ch01fig04">Figure 1.4</a> for an example of process 
creation and termination.</p>
<center>
<h5 id="ch01fig04" class="docFigureTitle">Figure 1.4. The <span class="docEmphasis">fork, exec, 
wait,</span> and <span class="docEmphasis">exit</span> system calls.</h5>
<p class="docText">
<img alt="graphics/01fig04.gif" src="01fig04.gif" border="0" width="500" height="414"></p>
</center>
<div align="center">
  <center>
<table cellSpacing="0" width="90%" border="1" style="border-collapse: collapse" bordercolor="#111111" cellpadding="5">
  <tr>
    <td>
    <h2 class="docSidebarTitle">EXPLANATION</h2>
    <span style="FONT-WEIGHT: bold">
    <ol class="docList" type="1">
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The parent shell creates a copy of itself with the
      <span class="docEmphasis">fork</span> system call. The copy is called the 
      child shell.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The child shell has a new PID and is a copy of its 
      parent. It will share the CPU with the parent.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The kernel loads the <span class="docEmphasis">grep</span> 
      program into memory and executes (<span class="docEmphasis">exec</span>) 
      it in place of the child shell. The <span class="docEmphasis">grep</span> 
      program inherits the open files and environment from the child.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The <span class="docEmphasis">grep</span> program 
      exits, the kernel cleans up, and the parent is awakened.</span></li>
    </ol>
    </span></td>
  </tr>
</table>
  </center>
</div>
<h5 id="ch01list02" class="docExampleTitle">Example 1.2 </h5>
<pre>(C Shell)
1   % <span class="docEmphStrong">cp filex filey</span>
    % <span class="docEmphStrong">echo $status</span>
    <span class="docEmphasis">0</span>
2   % <span class="docEmphStrong">cp xyz</span>
    <span class="docEmphasis">Usage: cp [-ip] f1 f2; or: cp [-ipr] f1 ... fn d2</span>
    % <span class="docEmphStrong">echo $status</span>
    <span class="docEmphasis">1</span>

(Bourne and Korn Shells)
3   $ <span class="docEmphStrong">cp filex filey</span>
    $ <span class="docEmphStrong">echo $?</span>
    <span class="docEmphasis">0</span>
    $ <span class="docEmphStrong">cp xyz</span>
    <span class="docEmphasis">Usage: cp [-ip] f1 f2; or: cp [-ipr] f1 ... fn d2</span>
    $ <span class="docEmphStrong">echo $?</span>
    <span class="docEmphasis">1</span></pre>
<div align="center">
  <center>
  <table cellSpacing="0" width="90%" border="1" style="border-collapse: collapse" bordercolor="#111111" cellpadding="5">
    <tr>
      <td>
      <h2 class="docSidebarTitle">EXPLANATION</h2>
      <span style="FONT-WEIGHT: bold">
      <ol class="docList" type="1">
        <li><span style="FONT-WEIGHT: normal">
        <p class="docList">The <span class="docEmphasis">cp</span> (copy) 
        command is entered at the C shell command line prompt. After the command 
        has made a copy of <span class="docEmphasis">filex</span> called
        <span class="docEmphasis">filey,</span> the program exits and the prompt 
        appears. The csh <span class="docEmphasis">status</span> variable 
        contains the exit status of the last command that was executed. If the 
        status is zero, the <span class="docEmphasis">cp</span> program exited 
        with success. If the exit status is nonzero, the
        <span class="docEmphasis">cp</span> program failed in some way.</span></li>
        <li><span style="FONT-WEIGHT: normal">
        <p class="docList">When entering the <span class="docEmphasis">cp</span> 
        command, the user failed to provide two filenames: the source and 
        destination files. The <span class="docEmphasis">cp</span> program sent 
        an error message to the screen and exited with a status of one. That 
        number is stored in the csh <span class="docEmphasis">status</span> 
        variable. Any number other than zero indicates that the program failed.</span></li>
        <li><span style="FONT-WEIGHT: normal">
        <p class="docList">The Bourne and Korn shells process the
        <span class="docEmphasis">cp</span> command as the C shell did in the 
        first two examples. The only difference is that the Bourne and Korn 
        shells store the exit status in the <span class="docEmphasis">?</span> 
        variable, rather than the <span class="docEmphasis">status</span> 
        variable.</span></li>
      </ol>
      </span></td>
    </tr>
  </table>
  </center>
</div>
<h3 class="docSection1Title" id="ch01lev1sec4">1.4 The Environment and Inheritance</h3>
<p class="docText">When you log on, the shell starts up and inherits a number of 
variables, I/O streams, and process characteristics from the
<span class="docEmphasis">/bin/login</span> program that started it. In turn, if 
another shell is spawned (forked) from the login or parent shell, that child 
shell (<span class="docEmphasis">subshell</span>) will inherit certain 
characteristics from its parent. A subshell may be started for a number of 
reasons: for handling background processing, for handling groups of commands, or 
for executing scripts. The child shell inherits an environment from its parent. 
The environment consists of process permissions (who owns the process), the 
working directory, the file creation mask, special variables, open files, and 
signals.</p>
<h4 class="docSection2Title" id="ch01lev2sec10">1.4.1 Ownership</h4>
<p class="docText">When you log on, the shell is given an identity. It has a 
real user identification (<span class="docEmphasis">UID</span>), one or more 
real group identifications (<span class="docEmphasis">GID</span>), and an 
effective user identification and effective group identification (<span class="docEmphasis">EUID</span> 
and <span class="docEmphasis">EGID</span>). The EUID and EGID are initially the 
same as the real UID and GID. These ID numbers are found in the
<span class="docEmphasis">passwd</span> file and are used by the system to 
identify users and groups. The EUID and EGID determine what permissions a 
process has access to when reading, writing, or executing files. If the EUID of 
a process and the real UID of the owner of the file are the same, the process 
has the owner's access permissions for the file. If the EGID and real GID of a 
process are the same, the process has the owner's group privileges.</p>
<p class="docText">The real UID, from the <span class="docEmphasis">/etc/passwd</span> 
file, is a positive integer associated with your login name. The real UID is the 
third field in the password file. When you log on, the login shell is assigned 
the real UID and all processes spawned from the login shell inherit its 
permissions. Any process running with a UID of zero belongs to root (the 
superuser) and has root privileges. The real group identification, the GID, 
associates a group with your login name. It is found in the fourth field of the 
password file.</p>
<p class="docText">The EUID and EGID can be changed to numbers assigned to a 
different owner. By changing the EUID (or EGID<span id="ENB1-4"><a class="docLink" href="#EN1-4"><sup>[4]</sup></a></span>) 
to another owner, you can become the owner of a process that belongs to someone 
else. Programs that change the EUID or EGID to another owner are called
<span class="docEmphasis">setuid</span> or <span class="docEmphasis">setgid</span> 
programs. The <span class="docEmphasis">/bin/passwd</span> program is an example 
of a <span class="docEmphasis">setuid</span> program that gives the user root 
privileges. <span class="docEmphasis">Setuid</span> programs are often sources 
for security holes. The shell allows you to create <span class="docEmphasis">
setuid</span> scripts, and the shell itself may be a <span class="docEmphasis">
setuid</span> program.</p>
<h4 class="docSection2Title" id="ch01lev2sec11">1.4.2 The File Creation Mask</h4>
<p class="docText">When a file is created, it is given a set of default 
permissions. These permissions are determined by the program creating the file. 
Child processes inherit a default mask from their parents. The user can change 
the mask for the shell by issuing the <span class="docEmphasis">umask</span> 
command at the prompt or by setting it in the shell's initialization files. The
<span class="docEmphasis">umask</span> command is used to remove permissions 
from the existing mask.</p>
<p class="docText">Initially, the <span class="docEmphasis">umask</span> is 000, 
giving a directory 777 (<span class="docEmphasis">rwxrwxrwx</span>) permissions 
and a file 666 (<span class="docEmphasis">rw–rw–rw–</span>) permissions as the 
default. On most systems, the <span class="docEmphasis">umask</span> is assigned 
a value of <span class="docEmphasis">022</span> by the <span class="docEmphasis">
/bin/login</span> program or the <span class="docEmphasis">/etc/profile</span> 
initialization file.</p>
<p class="docText">The <span class="docEmphasis">umask</span> value is 
subtracted from the default settings for both the directory and file permissions 
as follows:</p>
<pre> 777 (Directory)       666 (File)
–022 (umask value)    –022 (umask value)
-------               ---------
 755                   644

Result: d<span class="docEmphStrong">rwxr-xr-x</span>    -<span class="docEmphStrong">rw-r--r--</span>
</pre>
<p class="docText">After the <span class="docEmphasis">umask</span> is set, all 
directories and files created by this process are assigned the new default 
permissions. In this example, directories will be given read, write, and execute 
for the owner; read and execute for the group; and read and execute for the rest 
of the world (others). Any files created will be assigned read and write for the 
owner, and read for the group and others. To change permissions on individual 
directories and permissions, the <span class="docEmphasis">chmod</span> command 
is used.</p>
<h4 class="docSection2Title" id="ch01lev2sec12">1.4.3 Changing Permissions with
<span class="docEmphasis">chmod</span></h4>
<p class="docText">There is one owner for every UNIX file. Only the owner or the 
superuser can change the permissions on a file or directory by issuing the
<span class="docEmphasis">chmod</span> command. The following example 
illustrates the permissions modes. A group may have a number of members, and the 
owner of the file may change the group permissions on a file so that the group 
can enjoy special privileges.</p>
<p class="docText">The <span class="docEmphasis">chown</span> command changes 
the owner and group on files and directories. Only the owner or superuser can 
invoke it. On BSD versions of UNIX, only the superuser,
<span class="docEmphasis">root,</span> can change ownership.</p>
<p class="docText">Every UNIX file has a set of permissions associated with it 
to control who can read, write, or execute the file. A total of nine bits 
constitutes the permissions on a file. The first set of three bits controls the 
permissions of the owner of the file, the second set controls the permissions of 
the group, and the last set controls the permissions of everyone else. The 
permissions are stored in the <span class="docEmphasis">mode</span> field of the 
file's inode.</p>
<p class="docText">The <span class="docEmphasis">chmod</span> command changes 
permissions on files and directories. The user must own the files to change 
permissions on them.<span id="ENB1-5"><a class="docLink" href="#EN1-5"><sup>[5]</sup></a></span></p>
<p class="docText"><a class="docLink" href="#ch01table01">Table 1.1</a> 
illustrates the eight possible combinations of numbers used for changing 
permissions.</p>
<table cellSpacing="0" cellPadding="1" width="100%" border="1">
  <caption>
  <h5 id="ch01table01" class="docTableTitle">Table 1.1. Permission Modes</h5>
  </caption>
  <colgroup span="3" align="left">
  </colgroup>
  <tr>
    <th class="docTableHeader" vAlign="top"><span class="docEmphBoldItalic">
    Decimal</span> </th>
    <th class="docTableHeader" vAlign="top"><span class="docEmphBoldItalic">
    Octal</span> </th>
    <th class="docTableHeader" vAlign="top"><span class="docEmphBoldItalic">
    Permissions</span> </th>
  </tr>
  <tr>
    <td class="docTableCell" vAlign="top">0 </td>
    <td class="docTableCell" vAlign="top">000 </td>
    <td class="docTableCell" vAlign="top">none </td>
  </tr>
  <tr>
    <td class="docTableCell" vAlign="top">1 </td>
    <td class="docTableCell" vAlign="top">001 </td>
    <td class="docTableCell" vAlign="top">– –x </td>
  </tr>
  <tr>
    <td class="docTableCell" vAlign="top">2 </td>
    <td class="docTableCell" vAlign="top">010 </td>
    <td class="docTableCell" vAlign="top">–w– </td>
  </tr>
  <tr>
    <td class="docTableCell" vAlign="top">3 </td>
    <td class="docTableCell" vAlign="top">011 </td>
    <td class="docTableCell" vAlign="top">–wx </td>
  </tr>
  <tr>
    <td class="docTableCell" vAlign="top">4 </td>
    <td class="docTableCell" vAlign="top">100 </td>
    <td class="docTableCell" vAlign="top">r– – </td>
  </tr>
  <tr>
    <td class="docTableCell" vAlign="top">5 </td>
    <td class="docTableCell" vAlign="top">101 </td>
    <td class="docTableCell" vAlign="top">r–x </td>
  </tr>
  <tr>
    <td class="docTableCell" vAlign="top">6 </td>
    <td class="docTableCell" vAlign="top">110 </td>
    <td class="docTableCell" vAlign="top">rw– </td>
  </tr>
  <tr>
    <td class="docTableCell" vAlign="top">7 </td>
    <td class="docTableCell" vAlign="top">111 </td>
    <td class="docTableCell" vAlign="top">rwx </td>
  </tr>
</table>
<p class="docText">The symbolic notation for <span class="docEmphasis">chmod</span> 
is as follows:</p>
<p class="docText"><span class="docEmphasis">r</span> = read;
<span class="docEmphasis">w</span> = write; <span class="docEmphasis">x</span> = 
execute; <span class="docEmphasis">u</span> = user; <span class="docEmphasis">g</span> 
= group; <span class="docEmphasis">o</span> = others; <span class="docEmphasis">
a</span> = all.</p>
<h5 id="ch01list03" class="docExampleTitle">Example 1.3 </h5>
<pre>1   $ <span class="docEmphStrong">chmod 755 file</span>
    $ <span class="docEmphStrong">ls –l file</span>
    <span class="docEmphasis">–rwxr–xr–x 1 ellie 0 Mar   7 12:52 file</span>
2   $ <span class="docEmphStrong">chmod g+w file</span>
    $ <span class="docEmphStrong">ls -l file</span>
    <span class="docEmphasis">–rwxrwxr-x  1 ellie 0 Mar  7 12:54 file</span>
3   $ <span class="docEmphStrong">chmod go-rx file</span>
    $ <span class="docEmphStrong">ls -l file</span>
    <span class="docEmphasis">–rwx-w---- 1 ellie 0 Mar  7 12:56 file</span>
4   $ <span class="docEmphStrong">chmod a=r file</span>
    $ <span class="docEmphStrong">ls -l file</span>
    <span class="docEmphasis">–r--r--r-- 1 ellie 0 Mar  7 12:59 file</span>
</pre>
<div align="center">
  <center>
<table cellSpacing="0" width="90%" border="1" style="border-collapse: collapse" bordercolor="#111111" cellpadding="5">
  <tr>
    <td>
    <h2 class="docSidebarTitle">EXPLANATION</h2>
    <span style="FONT-WEIGHT: bold">
    <ol class="docList" type="1">
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The first argument is the octal value
      <span class="docEmphasis">755.</span> It turns on
      <span class="docEmphasis">rwx</span> for the user, and
      <span class="docEmphasis">r</span> and <span class="docEmphasis">x</span> 
      for the group and others for file.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">In the symbolic form of <span class="docEmphasis">chmod,</span> 
      write permission is added to the group.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">In the symbolic form of <span class="docEmphasis">chmod,</span> 
      read and execute permission are subtracted from the group and others.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">In the symbolic form of <span class="docEmphasis">chmod,</span> 
      all are given only read permission. The = sign causes all permissions to 
      be reset to the new value.</span></li>
    </ol>
    </span></td>
  </tr>
</table>
  </center>
</div>
<h5 id="ch01list04" class="docExampleTitle">Example 1.4 </h5>
<pre>(The Command Line)
1   $ <span class="docEmphStrong">chown steve filex</span>
2   $ ls -l

(The Output)
<span class="docEmphasis">-rwxrwxr-x 1</span> <span class="docEmphBoldItalic">steve</span> <span class="docEmphasis">groupa 170 Jul 28:20 filex</span>
</pre>
<div align="center">
  <center>
<table cellSpacing="0" width="90%" border="1" style="border-collapse: collapse" bordercolor="#111111" cellpadding="5">
  <tr>
    <td>
    <h2 class="docSidebarTitle">EXPLANATION</h2>
    <span style="FONT-WEIGHT: bold">
    <ol class="docList" type="1">
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The ownership of <span class="docEmphasis">filex</span> 
      is changed to <span class="docEmphasis">steve.</span></span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The <span class="docEmphasis">ls –l</span> command 
      displays the owner <span class="docEmphasis">steve</span> in column 3.</span></li>
    </ol>
    </span></td>
  </tr>
</table>
  </center>
</div>
<h4 class="docSection2Title" id="ch01lev2sec13">1.4.4 Changing Ownership with the
<span class="docEmphasis">chown</span> Command</h4>
<p class="docText"><b>The Working Directory.</b> When you log in, you are given 
a working directory within the file system, called the <span class="docEmphasis">
home directory.</span> The working directory is inherited by processes spawned 
from this shell. Any child process of this shell can change its own working 
directory, but the change will have no effect on the parent shell.</p>
<p class="docText">The <span class="docEmphasis">cd</span> command, used to 
change the working directory, is a shell built-in command. Each shell has its 
own copy of <span class="docEmphasis">cd.</span> A built-in command is executed 
directly by the shell as part of the shell's code; the shell does not perform 
the <span class="docEmphasis">fork</span> and <span class="docEmphasis">exec</span> 
system calls when executing built-in commands. If another shell (script) is 
forked from the parent shell, and the <span class="docEmphasis">cd</span> 
command is issued in the child shell, the directory will be changed in the child 
shell. When the child exits, the parent shell will be in the same directory it 
was in before the child started.</p>
<h5 id="ch01list05" class="docExampleTitle">Example 1.5 </h5>
<pre>1   % <span class="docEmphStrong">cd /</span>

2   % <span class="docEmphStrong">pwd</span>
    <span class="docEmphasis">/</span>

3   % <span class="docEmphStrong">sh</span>

4   $ <span class="docEmphStrong">cd /home</span>

5   $ <span class="docEmphStrong">pwd</span>
    <span class="docEmphasis">/home</span>

6   $ <span class="docEmphStrong">exit</span>

7   % <span class="docEmphStrong">pwd</span>
    <span class="docEmphasis">/</span>

    %
</pre>
<div align="center">
  <center>
<table cellSpacing="0" width="90%" border="1" style="border-collapse: collapse" bordercolor="#111111" cellpadding="5">
  <tr>
    <td>
    <h2 class="docSidebarTitle">EXPLANATION</h2>
    <span style="FONT-WEIGHT: bold">
    <ol class="docList" type="1">
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The prompt is a C shell prompt. The
      <span class="docEmphasis">cd</span> command changes directory to /. The
      <span class="docEmphasis">cd</span> command is built into the shell's 
      internal code.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The <span class="docEmphasis">pwd</span> command 
      displays the present working directory, /.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The Bourne shell is started.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The <span class="docEmphasis">cd</span> command changes 
      directories to <span class="docEmphasis">/home.</span></span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The <span class="docEmphasis">pwd</span> command 
      displays the present working directory, <span class="docEmphasis">/home.</span></span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The Bourne shell is exited, returning back to the C 
      shell.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">In the C shell, the present working directory is still 
      /. Each shell has its own copy of <span class="docEmphasis">cd.</span></span></li>
    </ol>
    </span></td>
  </tr>
</table>
  </center>
</div>
<p class="docText"><b>Variables.</b> The shell can define two types of 
variables: local and environment. The variables contain information used for 
customizing the shell, and information required by other processes so that they 
will function properly. Local variables are private to the shell in which they 
are created and not passed on to any processes spawned from that shell. 
Environment variables, on the other hand, are passed from parent to child 
process, from child to grandchild, and so on. Some of the environment variables 
are inherited by the login shell from the <span class="docEmphasis">/bin/login</span> 
program. Others are created in the user initialization files, in scripts, or at 
the command line. If an environment variable is set in the child shell, it is 
not passed back to the parent.</p>
<p class="docText"><b>File Descriptors.</b> All I/O, including files, pipes, and 
sockets, are handled by the kernel via a mechanism called the
<span class="docEmphasis">file</span> <span class="docEmphasis">descriptor.</span> 
A file descriptor is a small unsigned integer, an index into a file-descriptor 
table maintained by the kernel and used by the kernel to reference open files 
and I/O streams. Each process inherits its own file-descriptor table from its 
parent. The first three file descriptors, 0, 1, and 2, are assigned to your 
terminal. File descriptor 0 is standard input (<span class="docEmphasis">stdin</span>), 
1 is standard output (<span class="docEmphasis">stdout</span>), and 2 is 
standard error (<span class="docEmphasis">stderr</span>). When you open a file, 
the next available descriptor is 3, and it will be assigned to the new file. If 
all the available file descriptors are in use,<span id="ENB1-6"><a class="docLink" href="#EN1-6"><sup>[6]</sup></a></span> 
a new file cannot be opened. </p>
<p class="docText"><b>Redirection.</b> When a file descriptor is assigned to 
something other than a terminal, it is called <span class="docEmphasis">I/O 
redirection.</span> The shell performs redirection of output to a file by 
closing the standard output file descriptor, 1 (the terminal), and then 
assigning that descriptor to the file (<a class="docLink" href="#ch01fig05">Figure 
1.5</a>).When redirecting standard input, the shell closes file descriptor 0 
(the terminal) and assigns that descriptor to a file (<a class="docLink" href="#ch01fig06">Figure 
1.6</a>). The Bourne and Korn shells handle errors by assigning a file to file 
descriptor 2 (<a class="docLink" href="#ch01fig07">Figure 1.7</a>). The C shell, 
on the other hand, goes through a more complicated process to do the same thing 
(<a class="docLink" href="#ch01fig08">Figure 1.8</a>)</p>
<center>
<h5 id="ch01fig05" class="docFigureTitle">Figure 1.5. Redirection of standard output.</h5>
<p class="docText">
<img alt="graphics/01fig05.gif" src="01fig05.gif" border="0" width="497" height="406"></p>
</center><center>
<h5 id="ch01fig06" class="docFigureTitle">Figure 1.6. Redirection of standard input.</h5>
<p class="docText">
<img alt="graphics/01fig06.gif" src="01fig06.gif" border="0" width="500" height="380"></p>
</center><center>
<h5 id="ch01fig07" class="docFigureTitle">Figure 1.7. Redirection of standard error (Bourne and 
Korn shells).</h5>
<p class="docText">
<img alt="graphics/01fig07.gif" src="01fig07.gif" border="0" width="500" height="413"></p>
</center><center>
<h5 id="ch01fig08" class="docFigureTitle">Figure 1.8. Redirection of standard error (C shell).</h5>
<p class="docText">
<img alt="graphics/01fig08.gif" src="01fig08.gif" border="0" width="500" height="325"></p>
</center>
<h5 id="ch01list06" class="docExampleTitle">Example 1.6 </h5>
<pre>1   % who <span class="docEmphStrong">&gt;</span> file
2   % cat file1 file2 <span class="docEmphStrong">&gt;&gt;</span> file3
3   % mail tom &lt; file
4   % find / -name file -print <span class="docEmphStrong">2&gt;</span> errors
5   % ( find / -name file -print <span class="docEmphStrong">&gt;</span> /dev/tty) <span class="docEmphStrong">&gt;&amp;</span> errors
</pre>
<div align="center">
  <center>
<table cellSpacing="0" width="90%" border="1" style="border-collapse: collapse" bordercolor="#111111" cellpadding="5">
  <tr>
    <td>
    <h2 class="docSidebarTitle">EXPLANATION</h2>
    <span style="FONT-WEIGHT: bold">
    <ol class="docList" type="1">
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The output of the <span class="docEmphasis">who</span> 
      command is redirected from the terminal to <span class="docEmphasis">file.</span> 
      (All shells redirect output in this way.)</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The output from the <span class="docEmphasis">cat</span> 
      command (concatenate <span class="docEmphasis">file1</span> and
      <span class="docEmphasis">file2</span>) is appended to
      <span class="docEmphasis">file3.</span> (All shells redirect and append 
      output in this way.)</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The input of <span class="docEmphasis">file</span> is 
      redirected to the <span class="docEmphasis">mail</span> program; that is, 
      user <span class="docEmphasis">tom</span> will be sent the contents of
      <span class="docEmphasis">file.</span> (All shells redirect input in this 
      way.)</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">Any errors from the <span class="docEmphasis">find</span> 
      command are redirected to <span class="docEmphasis">errors.</span> Output 
      goes to the terminal. (The Bourne and Korn shells redirect errors this 
      way.)</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">Any errors from the <span class="docEmphasis">find</span> 
      command are redirected to <span class="docEmphasis">errors.</span> Output 
      is sent to the terminal. (The C shell redirects errors this way.)</span></li>
    </ol>
    </span></td>
  </tr>
</table>
  </center>
</div>
<p class="docText"><b>Pipes.</b> Pipes allow the output of one command to be 
sent to the input of another command. The shell implements pipes by closing and 
opening file descriptors; however, instead of assigning the descriptors to a 
file, it assigns them to a pipe descriptor created with the
<span class="docEmphasis">pipe</span> system call. After the parent creates the 
pipe file descriptors, it forks a child process for each command in the 
pipeline. By having each process manipulate the pipe descriptors, one will write 
to the pipe and the other will read from it. The pipe is merely a kernel buffer 
from which both processes can share data, thus eliminating the need for 
intermediate temporary files. After the descriptors are set up, the commands are
<span class="docEmphasis">exec</span>'ed concurrently. The output of one command 
is sent to the buffer, and when the buffer is full or the command has 
terminated, the command on the right-hand side of the pipe reads from the 
buffer. The kernel synchronizes the activities so that one process waits while 
the other reads from or writes from the buffer.</p>
<p class="docText">The syntax of the <span class="docEmphasis">pipe</span> 
command is</p>
<pre>who | wc
</pre>
<p class="docText">The shell sends the output of the <span class="docEmphasis">
who</span> command as input to the <span class="docEmphasis">wc</span> command. 
This is accomplished with the <span class="docEmphasis">pipe</span> system call. 
The parent shell calls the <span class="docEmphasis">pipe</span> system call, 
which creates two pipe descriptors, one for reading from the pipe and one for 
writing to it. The files associated with the pipe descriptors are kernel-managed 
I/O buffers used to temporarily store data, thus saving you the trouble of 
creating temporary files. <a class="docLink" href="#ch01fig09">Figures 1.9</a> 
through <a class="docLink" href="#ch01fig13">1.13</a> illustrate the steps for 
implementing the pipe.</p>
<center>
<h5 id="ch01fig09" class="docFigureTitle">Figure 1.9. The parent calls the
<span class="docEmphasis">pipe</span> system call for setting up a pipeline.</h5>
<p class="docText">
<img alt="graphics/01fig09.gif" src="01fig09.gif" border="0" width="500" height="357"></p>
</center><span style="FONT-WEIGHT: bold">
<ol class="docList">
  <li><span style="FONT-WEIGHT: normal" value="1">
  <p class="docList">The parent shell calls the <span class="docEmphasis">pipe</span> 
  system call. Two file descriptors are returned: one for reading from the pipe 
  and one for writing to the pipe. The file descriptors assigned are the next 
  available descriptors in the file-descriptor (fd) table,
  <span class="docEmphasis">fd 3</span> and <span class="docEmphasis">fd 4.</span> 
  See <a class="docLink" href="#ch01fig09">Figure 1.9</a>.</span></li>
  <li><span style="FONT-WEIGHT: normal" value="2">
  <p class="docList">For each command, <span class="docEmphasis">who</span> and
  <span class="docEmphasis">wc,</span> the parent forks a child process. Both 
  child processes get a copy of the parent's open file descriptors. See
  <a class="docLink" href="#ch01fig10">Figure 1.10</a>.</p>
  <center>
  <h5 id="ch01fig10" class="docFigureTitle">Figure 1.10. The parent forks two child processes, 
  one for each command in the pipeline.</h5>
  <p class="docText">
  <img alt="graphics/01fig10.gif" src="01fig10.gif" border="0" width="500" height="229"></p>
  </center></span></li>
  <li><span style="FONT-WEIGHT: normal" value="3">
  <p class="docList">The first child closes its standard output. It then 
  duplicates (the <span class="docEmphasis">dup</span> system call) file 
  descriptor <span class="docEmphasis">4,</span> the one associated with writing 
  to the pipe. The <span class="docEmphasis">dup</span> system call copies
  <span class="docEmphasis">fd 4</span> and assigns the copy to the lowest 
  available descriptor in the table, <span class="docEmphasis">fd 1.</span> 
  After it makes the copy, the <span class="docEmphasis">dup</span> call closes
  <span class="docEmphasis">fd 4.</span> The child will now close
  <span class="docEmphasis">fd 3</span> because it does not need it. This child 
  wants its standard <span class="docEmphasis">output</span> to go to the pipe. 
  See <a class="docLink" href="#ch01fig11">Figure 1.11</a>.</p>
  <center>
  <h5 id="ch01fig11" class="docFigureTitle">Figure 1.11. The first child is prepared to write 
  to the pipe.</h5>
  <p class="docText">
  <img alt="graphics/01fig11.gif" src="01fig11.gif" border="0" width="500" height="357"></p>
  </center></span></li>
  <li><span style="FONT-WEIGHT: normal" value="4">
  <p class="docList">Child 2 closes its standard input. It then duplicates (<span class="docEmphasis">dup</span>s)
  <span class="docEmphasis">fd 3,</span> which is associated with reading from 
  the pipe. By using <span class="docEmphasis">dup,</span> a copy of
  <span class="docEmphasis">fd 3</span> is created and assigned to the lowest 
  available descriptor. Since <span class="docEmphasis">fd 0</span> was closed, 
  it is the lowest available descriptor. <span class="docEmphasis">Dup</span> 
  closes <span class="docEmphasis">fd 3.</span> The child closes
  <span class="docEmphasis">fd 4.</span> Its standard <span class="docEmphasis">
  input</span> will come from the pipe. See <a class="docLink" href="#ch01fig12">
  Figure 1.12</a>.</p>
  <center>
  <h5 id="ch01fig12" class="docFigureTitle">Figure 1.12. The second child is prepared to read 
  input from the pipe.</h5>
  <p class="docText">
  <img alt="graphics/01fig12.gif" src="01fig12.gif" border="0" width="500" height="358"></p>
  </center></span></li>
  <li><span style="FONT-WEIGHT: normal" value="5">
  <p class="docList">The <span class="docEmphasis">who</span> command is 
  executed in place of Child 1 and the <span class="docEmphasis">wc</span> 
  command is executed to replace Child 2. The output of the
  <span class="docEmphasis">who</span> command goes into the pipe and is read by 
  the <span class="docEmphasis">wc</span> command from the other end of the 
  pipe. See <a class="docLink" href="#ch01fig13">Figure 1.13</a>.</p>
  <center>
  <h5 id="ch01fig13" class="docFigureTitle">Figure 1.13. The output of
  <span class="docEmphasis">who</span> is sent to the input of
  <span class="docEmphasis">wc.</span></h5>
  <p class="docText">
  <img alt="graphics/01fig13.gif" src="01fig13.gif" border="0" width="500" height="249"></p>
  </center></span></li>
</ol>
</span>
<h4 class="docSection2Title" id="ch01lev2sec14">1.4.5 The Shell and Signals</h4>
<p class="docText">A <span class="docEmphasis">signal</span> sends a message to 
a process and normally causes the process to terminate, usually owing to some 
unexpected event such as a segmentation violation, bus error, or power failure. 
You can send signals to a process by pressing the Break, Delete, Quit, or Stop 
keys, and all processes sharing the terminal are affected by the signal sent. 
You can kill a process with the <span class="docEmphasis">kill</span> command. 
By default, most signals terminate the program. The shells allow you to handle 
signals coming into your program, either by ignoring them or by specifying some 
action to be taken when a specified signal arrives. The C shell is limited to 
handling ^C (Control-C).</p>

<h3 class="docSection1Title" id="ch01lev1sec5">1.5 Executing Commands from Scripts</h3>
<p class="docText">When the shell is used as a programming language, commands 
and shell control constructs are typed in an editor and saved to a file, called 
a script. The lines from the file are read and executed one at a time by the 
shell. These programs are interpreted, not compiled. Compiled programs are 
converted into machine language before they are executed. Therefore, shell 
programs are usually slower than binary executables, but they are easier to 
write and are used mainly for automating simple tasks. Shell programs can also 
be written interactively at the command line, and for very simple tasks, this is 
the quickest way. However, for more complex scripting, it is easier to write 
scripts in an editor (unless you are a really great typist). The following 
script can be executed by any shell to output the same results.
<a class="docLink" href="#ch01fig14">Figure 1.14</a> illustrates the creation of 
a script called <span class="docEmphasis">doit</span> and how it fits in with 
already existing UNIX programs/utilities/commands.</p>
<center>
<h5 id="ch01fig14" class="docFigureTitle">Figure 1.14. Creating a generic shell script.</h5>
<p class="docText">
<img alt="graphics/01fig14.gif" src="01fig14.gif" border="0" width="500" height="373"></p>
</center>
<div align="center">
  <center>
  <table cellSpacing="0" width="90%" border="1" style="border-collapse: collapse" bordercolor="#111111" cellpadding="5">
    <tr>
      <td>
      <h2 class="docSidebarTitle">EXPLANATION</h2>
      <span style="FONT-WEIGHT: bold">
      <ol class="docList" type="1">
        <li><span style="FONT-WEIGHT: normal">
        <p class="docList">Go into your favorite editor and type in a set of 
        UNIX commands, one per line. Indicate what shell you want by placing the 
        pathname of the shell after the <span class="docEmphasis">#!</span> on 
        the first line. This program is being executed by the C shell and it is 
        named <span class="docEmphasis">doit.</span></span></li>
        <li><span style="FONT-WEIGHT: normal">
        <p class="docList">Save your file and turn on the execute permissions so 
        that you can run it.</span></li>
        <li><span style="FONT-WEIGHT: normal">
        <p class="docList">Execute your program just as you would any other UNIX 
        command.</span></li>
      </ol>
      </span></td>
    </tr>
  </table>
  </center>
</div>
<h4 class="docSection2Title" id="ch01lev2sec15">1.5.1 Sample Scripts: Comparing Three Shells</h4>
<p class="docText">At first glance, the following three programs look very 
similar. They are. And they all do the same thing. The main difference is the 
syntax. After you have worked with all three shells for some time, you will 
quickly adapt to the differences and start formulating your own opinions about 
which shell is your favorite. A detailed comparison of differences among the C, 
Bourne, and Korn shells is found in
<a class="docLink" href="Appendix B.htm">Appendix B</a>.</p>
<p class="docText">The following scripts send a mail message to a list of users, 
inviting each of them to a party. The place and time of the party are set in 
variables. The people to be invited are selected from a file called
<span class="docEmphasis">guests.</span> A list of foods is stored in a word 
list, and each person is asked to bring one of the foods from the list. If there 
are more users than food items, the list is reset so that each user is asked to 
bring a different food. The only user who is not invited is the user
<span class="docEmphasis">root.</span></p>
<h4 class="docSection2Title" id="ch01lev2sec16">1.5.2 The C Shell Script</h4>
<h5 id="ch01list07" class="docExampleTitle">Example 1.7 </h5>
<pre>1   #!/bin/csh –f
2   <span class="docEmphasis"># The Party Program––Invitations to friends from the &quot;guest&quot; file</span>
3   set guestfile = ~/shell/guests
4   if ( ! –e &quot;$guestfile&quot; ) then
        echo &quot;$guestfile:t non–existent&quot;
        exit 1
    endif
5   setenv PLACE &quot;Sarotini's&quot;
    @ Time = 'date +%H' + 1
    set food = ( cheese crackers shrimp drinks &quot;hot dogs&quot; sandwiches )
6   foreach person ( 'cat $guestfile' )
       if ( $person =~ root ) continue

7       mail –v –s &quot;Party&quot; $person &lt;&lt; FINIS   <span class="docEmphasis"># Start of here document</span>
        Hi ${person}! Please join me at $PLACE for a party!
        Meet me at    $Time o'clock.
        I'll bring the ice cream. Would you please bring $food[1] and
        anything else you would like to eat? Let me know if you can't
        make it. Hope to see you soon.
             Your pal,
             ellie@'hostname'       <span class="docEmphasis"># or 'uname -n'</span>
    FINIS
8       shift food
        if ( $#food ==  0 ) then
             set food = ( cheese crackers shrimp drinks &quot;hot dogs&quot;
                          sandwiches )
        endif
9    end

    echo &quot;Bye...&quot;</pre>
<div align="center">
  <center>
<table cellSpacing="0" width="90%" border="1" style="border-collapse: collapse" bordercolor="#111111" cellpadding="5">
  <tr>
    <td>
    <h2 class="docSidebarTitle">EXPLANATION</h2>
    <span style="FONT-WEIGHT: bold">
    <ol class="docList" type="1">
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">This line lets the kernel know that you are running a C 
      shell script. The <span class="docEmphasis">–f</span> option is a fast 
      startup. It says, &quot;Do not execute the <span class="docEmphasis">.cshrc</span> 
      file,&quot; an initialization file that is automatically executed every time a 
      new csh program is started.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">This is a comment. It is ignored by the shell, but 
      important for anyone trying to understand what the script is doing.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The variable <span class="docEmphasis">guestfile</span> 
      is set to the full pathname of a file called <span class="docEmphasis">
      guests.</span></span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">This line reads: If the file <span class="docEmphasis">
      guests</span> does not exist, then print to the screen &quot;<span class="docEmphasis">guests 
      nonexistent</span>&quot; and exit from the script with an exit status of 1 to 
      indicate that something went wrong in the program.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">Set variables are assigned the values for the place, 
      time, and list of foods to bring. The <span class="docEmphasis">PLACE</span> 
      variable is an environment variable. The <span class="docEmphasis">Time</span> 
      variable is a local variable. The @ symbol tells the C shell to perform 
      its built-in arithmetic; that is, add 1 to the <span class="docEmphasis">
      Time</span> variable after extracting the hour from the
      <span class="docEmphasis">date</span> command. The
      <span class="docEmphasis">Time</span> variable is spelled with an 
      uppercase <span class="docEmphasis">T</span> to prevent the C shell from 
      confusing it with one of its reserved words, <span class="docEmphasis">
      time.</span></span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">For each person on the guest list, except the user
      <span class="docEmphasis">root,</span> a mail message will be created 
      inviting the person to a party at a given place and time, and asking him 
      or her to bring one of the foods on the list.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The mail message is created in what is called a
      <span class="docEmphasis">here document.</span> All text from the 
      user-defined word <span class="docEmphasis">FINIS</span> to the final
      <span class="docEmphasis">FINIS</span> will be sent to the
      <span class="docEmphasis">mail</span> program. The
      <span class="docEmphasis">foreach</span> loop shifts through the list of 
      names, performing all of the instructions from the
      <span class="docEmphasis">foreach</span> to the keyword
      <span class="docEmphasis">end.</span></span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">After a message has been sent, the food list is shifted 
      so that the next person will get the next food item on the list. If there 
      are more people than food items, the food list will be reset to ensure 
      that each person is instructed to bring a food item.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">This marks the end of the looping statements.</span></li>
    </ol>
    </span></td>
  </tr>
</table>
  </center>
</div>
<h4 class="docSection2Title" id="ch01lev2sec17">1.5.3 The Bourne Shell Script</h4>
<h5 id="ch01list08" class="docExampleTitle">Example 1.8 </h5>
<pre>1   #!/bin/sh
2   <span class="docEmphasis"># The Party Program––Invitations to friends from the &quot;guest&quot; file</span>
3   guestfile=/home/jody/ellie/shell/guests
4   if [ ! –f &quot;$guestfile&quot; ]
    then
        echo &quot;'basename $guestfile' non–existent&quot;
        exit 1
    fi
5   PLACE=&quot;Sarotini's&quot;
    export PLACE
    Time='date +%H'
    Time='expr $Time + 1'
    set cheese crackers shrimp drinks &quot;hot dogs&quot; sandwiches
6   for person in 'cat $guestfile'
    do
        if [ $person =~ root ]
        then
             continue
        else
7            mail –v –s &quot;Party&quot; $person &lt;&lt;- FINIS
             Hi ${person}! Please join me at $PLACE for a party!
             Meet me at $Time o'clock.
             I'll bring the ice cream. Would you please bring $1 and
             anything else you would like to eat? Let me know if you
             can't make it. Hope to see you soon.
                 Your pal,
                 ellie@'hostname'
             FINIS
8            shift
             if [ $# –eq 0 ]
             then
                set cheese crackers shrimp drinks &quot;hot dogs&quot; sandwiches
             fi
        fi
9   done
    echo &quot;Bye...&quot;
</pre>
<div align="center">
  <center>
<table cellSpacing="0" width="90%" border="1" style="border-collapse: collapse" bordercolor="#111111" cellpadding="5">
  <tr>
    <td>
    <h2 class="docSidebarTitle">EXPLANATION</h2>
    <span style="FONT-WEIGHT: bold">
    <ol class="docList" type="1">
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">This line lets the kernel know that you are running a 
      Bourne shell script.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">This is a comment. It is ignored by the shell, but 
      important for anyone trying to understand what the script is doing.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The variable <span class="docEmphasis">guestfile</span> 
      is set to the full pathname of a file called <span class="docEmphasis">
      guests.</span></span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">This line reads: If the file <span class="docEmphasis">
      guests</span> does not exist, then print to the screen &quot;<span class="docEmphasis">guests 
      nonexistent</span>&quot; and exit from the script.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">Variables are assigned the values for the place and 
      time. The list of foods to bring is assigned to special variables 
      (positional parameters) with the <span class="docEmphasis">set</span> 
      command.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">For each person on the guest list, except the user
      <span class="docEmphasis">root,</span> a mail message will be created 
      inviting each person to a party at a given place and time, and asking each 
      to bring a food from the list.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The mail message is sent when this line is uncommented. 
      It is not a good idea to uncomment this line until the program has been 
      thoroughly debugged, otherwise the e-mail will be sent to the same people 
      every time the script is tested. The next statement, using the
      <span class="docEmphasis">cat</span> command with the
      <span class="docEmphasis">here document,</span> allows the script to be 
      tested by sending output to the screen that would normally be sent through 
      the mail when line 7 is uncommented.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">After a message has been sent, the food list is shifted 
      so that the next person will get the next food on the list. If there are 
      more people than foods, the food list will be reset, insuring that each 
      person is assigned a food.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">This marks the end of the looping statements.</span></li>
    </ol>
    </span></td>
  </tr>
</table>
  </center>
</div>
<h4 class="docSection2Title" id="ch01lev2sec18">1.5.4 The Korn Shell Script</h4>
<h5 id="ch01list09" class="docExampleTitle">Example 1.9 </h5>
<pre>1   #!/bin/ksh
2   <span class="docEmphasis"># The Party Program––Invitations to friends from the &quot;guest&quot; file</span>
3   guestfile=~/shell/guests
4   if [[ ! –a &quot;$guestfile&quot; ]]
    then
        print &quot;${guestfile##*/} non–existent&quot;
        exit 1
    fi
5   export PLACE=&quot;Sarotini's&quot;
    (( Time=$(date +%H) + 1 ))
    set cheese crackers shrimp drinks &quot;hot dogs&quot; sandwiches
6   for person in $(&lt; $guestfile)
    do
        if  [[ $person = root ]]
        then
             continue
        else

             <span class="docEmphasis"># Start of here document</span>
7            mail –v –s &quot;Party&quot; $person &lt;&lt;- FINIS
             Hi ${person}! Please join me at $PLACE for a party!
             Meet me at $Time o'clock.
             I'll bring the ice cream. Would you please bring $1
             and anything else you would like to eat? Let me know
             if you can't make it.
                    Hope to see you soon.
                            Your pal,
                            ellie@'hostname'
             FINIS
8            shift
             if (( $# ==  0 ))
             then
               set cheese crackers shrimp drinks &quot;hot dogs&quot; sandwiches
             fi
         fi
9   done
    print &quot;Bye...&quot;
</pre>
<div align="center">
  <center>
<table cellSpacing="0" width="90%" border="1" style="border-collapse: collapse" bordercolor="#111111" cellpadding="5">
  <tr>
    <td>
    <h2 class="docSidebarTitle">EXPLANATION</h2>
    <span style="FONT-WEIGHT: bold">
    <ol class="docList" type="1">
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">This line lets the kernel know that you are running a 
      Korn shell script.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">This is a comment. It is ignored by the shell, but 
      important for anyone trying to understand what the script is doing.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The variable <span class="docEmphasis">guestfile</span> 
      is set to the full pathname of a file called <span class="docEmphasis">
      guests.</span></span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">This line reads: If the file <span class="docEmphasis">
      guests</span> does not exist, then print to the screen &quot;<span class="docEmphasis">guests 
      nonexistent</span>&quot; and exit from the script.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">Variables are assigned the values for the place and 
      time. The list of foods to bring is assigned to special variables 
      (positional parameters) with the <span class="docEmphasis">set</span> 
      command.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">For each person on the guest list, except the user
      <span class="docEmphasis">root,</span> a mail message will be created 
      inviting the person to a party at a given place and time, and assigning a 
      food from the list to bring.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">The mail message is sent. The body of the message is 
      contained in a <span class="docEmphasis">here document.</span></span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">After a message has been sent, the food list is shifted 
      so that the next person will get the next food on the list. If there are 
      more people than foods, the food list will be reset, insuring that each 
      person is assigned a food.</span></li>
      <li><span style="FONT-WEIGHT: normal">
      <p class="docList">This marks the end of the looping statements.</span></li>
    </ol>
    </span></td>
  </tr>
</table>
  </center>
</div>
<blockquote>
<p class="docFootnote" id="EN1-1"><a class="docLink" href="#ENB1-1">[1]</a>&nbsp;&nbsp;The process of 
  breaking the line up into tokens is called <span class="docEmphasis">lexical 
  analysis.</span></p><p class="docFootnote" id="EN1-2"><a class="docLink" href="#ENB1-2">[2]</a>&nbsp;&nbsp;Numbers 3 and 4 
  are reversed for Bourne and Korn(88) shells. Number 3 does not apply for C and 
  TC shells.</p><p class="docFootnote" id="EN1-3"><a class="docLink" href="#ENB1-3">[3]</a>&nbsp;&nbsp;To remove zombie 
  processes, the system must be rebooted.</p><p class="docFootnote" id="EN1-4"><a class="docLink" href="#ENB1-4">[4]</a>&nbsp;&nbsp;The <span class="docEmphasis">setgid</span> permission is system-dependent in 
its use. On some systems, a <span class="docEmphasis">setgid</span> on a 
directory may cause files created in that directory to belong to the same group 
that is owned by the directory. On others, the EGID of the process determines 
the group that can use the file.</p><p class="docFootnote" id="EN1-5"><a class="docLink" href="#ENB1-5">[5]</a>&nbsp;&nbsp;The caller's EUID 
  must match the owner's UID of the file, or the owner must be superuser.</p><p class="docFootnote" id="EN1-6"><a class="docLink" href="#ENB1-6">[6]</a>&nbsp;&nbsp;See built-in 
  commands, <span class="docEmphasis">limit</span> and <span class="docEmphasis">
  ulimit.</span></p>
</blockquote>
<table width="100%" border="1" bgcolor="#EBEBFF"><tr><td width="5%" align="left" valign="middle"><a href="_chapter 0.htm"><img src="Larrow.gif" width="17" height="19" border="0"></a></td><td align="center" valign="middle"><a class="docLink" href="Front matter.htm">CONTENTS</a></td><td width="5%" align="right" valign="middle"><a href="_chapter 2.htm"><img src="Rarrow.gif" width="17" height="19" border="0"></a></td></tr></table></body>

</html>